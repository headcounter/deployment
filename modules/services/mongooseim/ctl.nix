{ pkgs, lib, hclib, config, ... }:

with lib;

let
  cfg = config.headcounter.programs.mongooseimctl;
  inherit (config.headcounter.services.mongooseim) package;

  mimlib = import ./lib.nix { inherit config hclib lib; };

  ctlArgsFile = pkgs.writeText "ctl.args" ''
    -setcookie ${hclib.shErlEsc hclib.erlAtom cfg.cookie}
    ${mimlib.loopbackArg}
    ${mimlib.inetArg}
    -pa ${hclib.shErlEsc id "${package.mainAppDir}/ebin"}
  '';

  mongooseimctl = pkgs.writeScriptBin "mongooseimctl" ''
    #!${pkgs.stdenv.shell}
    if [ "$1" = debug ]; then
      shift
      # If TERM is unset or "dumb" -remsh doesn't connect to the remote node.
      [ -z "$TERM" -o "$TERM" = dumb ] && export TERM=vt100
      exec ${pkgs.erlang}/bin/erl \
        -args_file ${lib.escapeShellArg ctlArgsFile} \
        -sname "ctl$$@"${lib.escapeShellArg cfg.ctlHost} \
        -hidden -remsh ${lib.escapeShellArg cfg.destNodeName} "$@"
    fi
    ${pkgs.erlang}/bin/erl \
      -args_file ${lib.escapeShellArg ctlArgsFile} \
      -sname "ctl$$@"${lib.escapeShellArg cfg.ctlHost} \
      -noinput -hidden -s ejabberd_ctl \
      -extra ${lib.escapeShellArg cfg.destNodeName} "$@"
    retcode=$?
    if [ $retcode -eq 2 -o $retcode -eq 3 ]; then
      echo
      echo "Use \`mongooseimctl debug' to enter an interactive Erlang shell" \
           "of a running MongooseIM node."
      exit $retcode
    fi
  '';

in {
  options.headcounter.programs.mongooseimctl = {
    enable = mkEnableOption "MongooseIM controller";

    ctlHost = mkOption {
      default = config.networking.hostName;
      type = types.str;
      description = ''
        The host part of the node name to use for spawning the client side of
        the controller. A random node name will be generated at runtime.
      '';
    };

    destNodeName = mkOption {
      default = "mongooseim@${config.networking.hostName}";
      type = types.str;
      description = ''
        Erlang node name of the MongooseIM server to control.
      '';
    };

    cookie = mkOption {
      example = "super_secret_random_sequence";
      type = types.str;
      description = ''
        The magic cookie used for communicating with the MongooseIM Erlang node.
      '';
    };

    ctlTool = mkOption {
      type = types.path;
      internal = true;
      description = ''
        The full path to the <literal>mongooseimctl</literal> tool, generated by
        this very module.
      '';
    };
  };

  config = mkIf cfg.enable {
    environment.systemPackages = singleton mongooseimctl;
    headcounter.programs.mongooseimctl = {
      ctlTool = "${mongooseimctl}/bin/mongooseimctl";
    };
  };
}
